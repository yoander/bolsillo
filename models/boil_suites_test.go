// This file is generated by SQLBoiler (https://github.com/volatiletech/sqlboiler)
// and is meant to be re-generated in place and/or deleted at any time.
// DO NOT EDIT

package models

import "testing"

// This test suite runs each operation test in parallel.
// Example, if your database has 3 tables, the suite will run:
// table1, table2 and table3 Delete in parallel
// table1, table2 and table3 Insert in parallel, and so forth.
// It does NOT run each operation group in parallel.
// Separating the tests thusly grants avoidance of Postgres deadlocks.
func TestParent(t *testing.T) {
	t.Run("Invoices", testInvoices)
	t.Run("Persons", testPersons)
	t.Run("Tags", testTags)
	t.Run("Transactions", testTransactions)
	t.Run("Units", testUnits)
}

func TestDelete(t *testing.T) {
	t.Run("Invoices", testInvoicesDelete)
	t.Run("Persons", testPersonsDelete)
	t.Run("Tags", testTagsDelete)
	t.Run("Transactions", testTransactionsDelete)
	t.Run("Units", testUnitsDelete)
}

func TestQueryDeleteAll(t *testing.T) {
	t.Run("Invoices", testInvoicesQueryDeleteAll)
	t.Run("Persons", testPersonsQueryDeleteAll)
	t.Run("Tags", testTagsQueryDeleteAll)
	t.Run("Transactions", testTransactionsQueryDeleteAll)
	t.Run("Units", testUnitsQueryDeleteAll)
}

func TestSliceDeleteAll(t *testing.T) {
	t.Run("Invoices", testInvoicesSliceDeleteAll)
	t.Run("Persons", testPersonsSliceDeleteAll)
	t.Run("Tags", testTagsSliceDeleteAll)
	t.Run("Transactions", testTransactionsSliceDeleteAll)
	t.Run("Units", testUnitsSliceDeleteAll)
}

func TestExists(t *testing.T) {
	t.Run("Invoices", testInvoicesExists)
	t.Run("Persons", testPersonsExists)
	t.Run("Tags", testTagsExists)
	t.Run("Transactions", testTransactionsExists)
	t.Run("Units", testUnitsExists)
}

func TestFind(t *testing.T) {
	t.Run("Invoices", testInvoicesFind)
	t.Run("Persons", testPersonsFind)
	t.Run("Tags", testTagsFind)
	t.Run("Transactions", testTransactionsFind)
	t.Run("Units", testUnitsFind)
}

func TestBind(t *testing.T) {
	t.Run("Invoices", testInvoicesBind)
	t.Run("Persons", testPersonsBind)
	t.Run("Tags", testTagsBind)
	t.Run("Transactions", testTransactionsBind)
	t.Run("Units", testUnitsBind)
}

func TestOne(t *testing.T) {
	t.Run("Invoices", testInvoicesOne)
	t.Run("Persons", testPersonsOne)
	t.Run("Tags", testTagsOne)
	t.Run("Transactions", testTransactionsOne)
	t.Run("Units", testUnitsOne)
}

func TestAll(t *testing.T) {
	t.Run("Invoices", testInvoicesAll)
	t.Run("Persons", testPersonsAll)
	t.Run("Tags", testTagsAll)
	t.Run("Transactions", testTransactionsAll)
	t.Run("Units", testUnitsAll)
}

func TestCount(t *testing.T) {
	t.Run("Invoices", testInvoicesCount)
	t.Run("Persons", testPersonsCount)
	t.Run("Tags", testTagsCount)
	t.Run("Transactions", testTransactionsCount)
	t.Run("Units", testUnitsCount)
}

func TestHooks(t *testing.T) {
	t.Run("Invoices", testInvoicesHooks)
	t.Run("Persons", testPersonsHooks)
	t.Run("Tags", testTagsHooks)
	t.Run("Transactions", testTransactionsHooks)
	t.Run("Units", testUnitsHooks)
}

func TestInsert(t *testing.T) {
	t.Run("Invoices", testInvoicesInsert)
	t.Run("Invoices", testInvoicesInsertWhitelist)
	t.Run("Persons", testPersonsInsert)
	t.Run("Persons", testPersonsInsertWhitelist)
	t.Run("Tags", testTagsInsert)
	t.Run("Tags", testTagsInsertWhitelist)
	t.Run("Transactions", testTransactionsInsert)
	t.Run("Transactions", testTransactionsInsertWhitelist)
	t.Run("Units", testUnitsInsert)
	t.Run("Units", testUnitsInsertWhitelist)
}

// TestToOne tests cannot be run in parallel
// or deadlocks can occur.
func TestToOne(t *testing.T) {
	t.Run("TransactionToInvoiceUsingInvoice", testTransactionToOneInvoiceUsingInvoice)
	t.Run("TransactionToPersonUsingPerson", testTransactionToOnePersonUsingPerson)
	t.Run("TransactionToUnitUsingUnit", testTransactionToOneUnitUsingUnit)
	t.Run("UnitToUnitUsingUnit", testUnitToOneUnitUsingUnit)
}

// TestOneToOne tests cannot be run in parallel
// or deadlocks can occur.
func TestOneToOne(t *testing.T) {}

// TestToMany tests cannot be run in parallel
// or deadlocks can occur.
func TestToMany(t *testing.T) {
	t.Run("InvoiceToTransactions", testInvoiceToManyTransactions)
	t.Run("PersonToTransactions", testPersonToManyTransactions)
	t.Run("TagToTransactions", testTagToManyTransactions)
	t.Run("TransactionToTags", testTransactionToManyTags)
	t.Run("UnitToTransactions", testUnitToManyTransactions)
	t.Run("UnitToUnits", testUnitToManyUnits)
}

// TestToOneSet tests cannot be run in parallel
// or deadlocks can occur.
func TestToOneSet(t *testing.T) {
	t.Run("TransactionToInvoiceUsingInvoice", testTransactionToOneSetOpInvoiceUsingInvoice)
	t.Run("TransactionToPersonUsingPerson", testTransactionToOneSetOpPersonUsingPerson)
	t.Run("TransactionToUnitUsingUnit", testTransactionToOneSetOpUnitUsingUnit)
	t.Run("UnitToUnitUsingUnit", testUnitToOneSetOpUnitUsingUnit)
}

// TestToOneRemove tests cannot be run in parallel
// or deadlocks can occur.
func TestToOneRemove(t *testing.T) {
	t.Run("TransactionToInvoiceUsingInvoice", testTransactionToOneRemoveOpInvoiceUsingInvoice)
	t.Run("TransactionToUnitUsingUnit", testTransactionToOneRemoveOpUnitUsingUnit)
	t.Run("UnitToUnitUsingUnit", testUnitToOneRemoveOpUnitUsingUnit)
}

// TestOneToOneSet tests cannot be run in parallel
// or deadlocks can occur.
func TestOneToOneSet(t *testing.T) {}

// TestOneToOneRemove tests cannot be run in parallel
// or deadlocks can occur.
func TestOneToOneRemove(t *testing.T) {}

// TestToManyAdd tests cannot be run in parallel
// or deadlocks can occur.
func TestToManyAdd(t *testing.T) {
	t.Run("InvoiceToTransactions", testInvoiceToManyAddOpTransactions)
	t.Run("PersonToTransactions", testPersonToManyAddOpTransactions)
	t.Run("TagToTransactions", testTagToManyAddOpTransactions)
	t.Run("TransactionToTags", testTransactionToManyAddOpTags)
	t.Run("UnitToTransactions", testUnitToManyAddOpTransactions)
	t.Run("UnitToUnits", testUnitToManyAddOpUnits)
}

// TestToManySet tests cannot be run in parallel
// or deadlocks can occur.
func TestToManySet(t *testing.T) {
	t.Run("InvoiceToTransactions", testInvoiceToManySetOpTransactions)
	t.Run("TagToTransactions", testTagToManySetOpTransactions)
	t.Run("TransactionToTags", testTransactionToManySetOpTags)
	t.Run("UnitToTransactions", testUnitToManySetOpTransactions)
	t.Run("UnitToUnits", testUnitToManySetOpUnits)
}

// TestToManyRemove tests cannot be run in parallel
// or deadlocks can occur.
func TestToManyRemove(t *testing.T) {
	t.Run("InvoiceToTransactions", testInvoiceToManyRemoveOpTransactions)
	t.Run("TagToTransactions", testTagToManyRemoveOpTransactions)
	t.Run("TransactionToTags", testTransactionToManyRemoveOpTags)
	t.Run("UnitToTransactions", testUnitToManyRemoveOpTransactions)
	t.Run("UnitToUnits", testUnitToManyRemoveOpUnits)
}

func TestReload(t *testing.T) {
	t.Run("Invoices", testInvoicesReload)
	t.Run("Persons", testPersonsReload)
	t.Run("Tags", testTagsReload)
	t.Run("Transactions", testTransactionsReload)
	t.Run("Units", testUnitsReload)
}

func TestReloadAll(t *testing.T) {
	t.Run("Invoices", testInvoicesReloadAll)
	t.Run("Persons", testPersonsReloadAll)
	t.Run("Tags", testTagsReloadAll)
	t.Run("Transactions", testTransactionsReloadAll)
	t.Run("Units", testUnitsReloadAll)
}

func TestSelect(t *testing.T) {
	t.Run("Invoices", testInvoicesSelect)
	t.Run("Persons", testPersonsSelect)
	t.Run("Tags", testTagsSelect)
	t.Run("Transactions", testTransactionsSelect)
	t.Run("Units", testUnitsSelect)
}

func TestUpdate(t *testing.T) {
	t.Run("Invoices", testInvoicesUpdate)
	t.Run("Persons", testPersonsUpdate)
	t.Run("Tags", testTagsUpdate)
	t.Run("Transactions", testTransactionsUpdate)
	t.Run("Units", testUnitsUpdate)
}

func TestSliceUpdateAll(t *testing.T) {
	t.Run("Invoices", testInvoicesSliceUpdateAll)
	t.Run("Persons", testPersonsSliceUpdateAll)
	t.Run("Tags", testTagsSliceUpdateAll)
	t.Run("Transactions", testTransactionsSliceUpdateAll)
	t.Run("Units", testUnitsSliceUpdateAll)
}

func TestUpsert(t *testing.T) {
	t.Run("Invoices", testInvoicesUpsert)
	t.Run("Persons", testPersonsUpsert)
	t.Run("Tags", testTagsUpsert)
	t.Run("Transactions", testTransactionsUpsert)
	t.Run("Units", testUnitsUpsert)
}
